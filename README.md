# BiotSavartSolver
A Simple Biot Savart Solver in Python

## Requirements:
- Python 2.7 or higher
- numpy
- scipy
- matplotlib

## Some theory
According to the Biot Savart Law, a field generated by an arbitrarily shaped wire described by the curve ![equation](https://latex.codecogs.com/gif.latex?%5Cgamma) carrying a complex current I at the point described by the displacement vector ![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7Br%7D) in the vacuum is:

![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7BB%7D%3D%5Cfrac%7B%5Cmu_%7B0%7D%7D%7B4%5Cpi%7D%5Cint_%7B%5Cgamma%7D%5Cfrac%7BI%5Coverrightarrow%7Bdl%7D%5Ctimes%5Coverrightarrow%7Br%7D%7D%7B%5Cleft%5CVert%20%5Coverrightarrow%7Br%7D%5Cright%5CVert%20%5E%7B3%7D%7D)

So an infinitesimal contribute by the infinitesimal piece of wire ![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7Bdl%7D) will be:

![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7BdB%7D%3D%5Cfrac%7B%5Cmu_%7B0%7DI%7D%7B4%5Cpi%7D%5Cfrac%7B%5Coverrightarrow%7Bdl%7D%5Ctimes%5Coverrightarrow%7Br%7D%7D%7B%5Cleft%5CVert%20r%5Cright%5CVert%20%5E%7B3%7D%7D)

Now we want to discretize this integral to make it computer-solvable, so we approximate ![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7BdB%7D) with ![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7B%5CDelta%20B%7D):

![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7B%5CDelta%20B%7D%3D%5Cfrac%7B%5Cmu_%7B0I%7D%7D%7B4%5Cpi%7D%5Cfrac%7B%5Coverrightarrow%7B%5CDelta%20l%7D%5Ctimes%5Coverrightarrow%7Br%7D%7D%7B%5Cleft%5CVert%20r%5Cright%5CVert%20%5E%7B3%7D%7D)

where the displacement vector ![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7Br%7D) now is simply calculated from the center coordinates of ![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7B%5CDelta%20l%7D), which is a discretized segment of the original wire, short enough to apply these approximations.

Now we calculate ![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7BB%7D) simply by adding together each contribute from each discretized piece of wire, that is:

![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7BB%7D%3D%5Cdisplaystyle%5Csum%5Climits_%7Bi%3D1%7D%5EN%20%5Coverrightarrow%7B%5CDelta%20B%7D_%7Bi%7D)

Where the wire ![equation](https://latex.codecogs.com/gif.latex?%5Cgamma) is supposed to be discretized in N pieces. More advanced discretization techniques could be used, such as the Simpson’s rule, but for our purposes this kind of approach will suffice.

## The code:

Here a brief description of the source files (i.e. *.py files).

 - myShapes.py contains the Wire class, that implements a simple wire with some useful presets. This class has a property “coordz” that is a List formed by N+1 1×3 numpy.array representing the vertices of N segments of the wire, and a property I that is the complex current carried by the wire. You can define your own wires, although you can initialize it as a solenoid, loop, toroidal solenoid or segmented wire. Examples of these operations can be found in “Test_Shapes.py”
- Test_Shapes.py: examples on how to use the wire class and plotting of the results
- Discretizer.py: dicretizes a wire uniformly at a custom length. Examples on how to use this class can be found in “Test_Discretize.py”
- Test_Discretize.py  examples on how to use the Discretizer class
-  Biot_Savart.py: the core solver, it implements a solver as described above. Given a wire, the discretization length and the points on which perform the evaluation it returns the complex vector field B and can return also the absolute value of the norm of B.
-  Files named after “Test_Biot_Savart_*.py” will be showed in the next section

## Validation

I validated my solver confronting its results against theoretical results given in literature:

- Test_Biot_Savart_wire.py solves the B field given a long wire toward the z-axis on some points on the center of the wire toward the y-axis
- Test_Biot_Savart_solenoid.py solves the B field given a solenoid on some points in the center axis of it
- Test_Biot_Savart_toroidal_solenoid.py solves the B field on the center axis of a toroidal solenoid

Here some images of the wires:

![Toroid](images/toroid.png)

![Solenoid](images/solenoid.png)

![Loop](images/loop.png)

Since quiver3D seems not to be implemented in matplotlib3D I haven’t added it yet in the scripts. So I simply plotted the absolute value of the norm of B against distance for the wire and the loop, and calculated the RMSE for every test. Now the 4 cases described;

For a straight long wire carrying a current I at a distance r from the wire the B field will have only one component on the azimuth i.e.:

![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7BB%7D%3D%5Cfrac%7B%5Cmu_%7B0%7DI%7D%7B2%5Cpi%20r%7D%20%5Chat%7B%5Cvarphi%7D)

So, running Test_Biot_Savart_loop.py we will see the plot Below:

![Loop](images/wire.png)

and on the console we will see:

RMSE: 2.43426286502e-10

Analytical B (mean): 5.85793650794e-08 Tesla

Thus the Root Mean Squared Error is very small compared to the average B.

For a Circular loop of radius R carrying current I (loop in yz plane, at distance x along x-axis) we have:

![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7BB%7D%3D%5Cfrac%7B%5Cmu_%7B0%7DIR%5E%7B2%7D%7D%7B2%5Cleft%28x%5E%7B2%7D&plus;R%5E%7B2%7D%5Cright%29%5E%7B%5Cfrac%7B3%7D%7B2%7D%7D%7D%5Chat%7Bx%7D)

So, running Test_Biot_Savart_loop.py we will see the plot Below:

![Loop](images/loopplot.png)

and on the console we will see:

RMSE: 9.49980867342e-12

Analytical B (mean): 2.56313225429e-08 Tesla

Thus the Root Mean Squared Error is very small compared to the average B.

For a Solenoid with N turns and length l carrying current I (inside) B is constant and directed along the central axis:

![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7BB%7D%3D%5Cfrac%7B%5Cmu_%7B0%7DNI%7D%7Bl%7D%5Chat%7Bx%7D)

and running Test_Biot_Savart_Solenoid.py we will see:

RMSE: 6.97877827573e-05

Analytical B: 0.000125663706144 Tesla

Thus the Root Mean Squared Error is very small compared to B.

For a Torus with N turns and radius r carrying current I (inside) B is constant and directed along the central axis:

![equation](https://latex.codecogs.com/gif.latex?%5Coverrightarrow%7BB%7D%3D%5Cfrac%7B%5Cmu_%7B0%7DNI%7D%7B2%5Cpi%20r%7D%5Chat%7B%5Cvarphi%7D)

and running Test_Biot_Savart_Toroidal_Solenoid.py we will see:

RMSE: 1.81013590516e-09

Analytical B: 2e-06 Tesla

Thus the Root Mean Squared Error is very small compared to B.
